---
title: 团队（Crews）
description: 在 CrewAI 框架中理解和使用团队的综合属性和功能。
icon: people-group
---

## 概述

CrewAI 中的团队（Crew）代表一组智能体（Agents）协作工作以完成一系列任务（Tasks）的协作小组。每个团队定义任务执行策略、智能体协作方式和整体工作流程。

## 团队属性

| 属性                      | 参数                   | 描述                                                                                                                                     |
| :------------------------ | :--------------------- | :--------------------------------------------------------------------------------------------------------------------------------------- |
| **任务**                  | `tasks`                | 分配给团队的任务列表。                                                                                                                   |
| **智能体**                | `agents`               | 团队成员的智能体列表。                                                                                                                   |
| **流程** _(可选)_         | `process`              | 团队遵循的流程（例如，顺序流程 Sequential、分层流程 Hierarchical）。默认为 `sequential`。                                                |
| **详细输出** _(可选)_     | `verbose`              | 执行期间的日志详细程度。默认为 `False`。                                                                                                 |
| **管理器 LLM** _(可选)_   | `manager_llm`          | 分层流程中管理器智能体使用的语言模型。**使用分层流程时必需。**                                                                           |
| **函数调用 LLM** _(可选)_ | `function_calling_llm` | 如果传递，团队将使用此 LLM 为团队中所有智能体的工具进行函数调用。每个智能体可以有自己的 LLM，这会覆盖团队的函数调用 LLM。                |
| **配置** _(可选)_         | `config`               | 团队的可选配置设置，格式为 `Json` 或 `Dict[str, Any]`。                                                                                  |
| **最大 RPM** _(可选)_     | `max_rpm`              | 团队在执行期间遵守的每分钟最大请求数。默认为 `None`。                                                                                    |
| **记忆** _(可选)_         | `memory`               | 用于存储执行记忆（短期、长期、实体记忆）。                                                                                               |
| **记忆配置** _(可选)_     | `memory_config`        | 团队使用的记忆提供者配置。                                                                                                               |
| **缓存** _(可选)_         | `cache`                | 指定是否使用缓存存储工具执行结果。默认为 `True`。                                                                                        |
| **嵌入器** _(可选)_       | `embedder`             | 团队使用的嵌入器配置。主要用于记忆功能。默认为 `{"provider": "openai"}`。                                                                |
| **步骤回调** _(可选)_     | `step_callback`        | 每个智能体每步执行后调用的函数。可用于记录智能体行为或执行其他操作；不会覆盖智能体特定的 `step_callback`。                               |
| **任务回调** _(可选)_     | `task_callback`        | 每个任务完成后调用的函数。对任务执行后的监控或其他操作有用。                                                                             |
| **共享团队** _(可选)_     | `share_crew`           | 是否要与 crewAI 团队分享完整的团队信息和执行情况以改进库，并允许我们训练模型。                                                           |
| **输出日志文件** _(可选)_ | `output_log_file`      | 设置为 True 以在当前目录中保存日志为 logs.txt，或提供文件路径。如果文件名以 .json 结尾，日志将为 JSON 格式，否则为 .txt。默认为 `None`。 |
| **管理器智能体** _(可选)_ | `manager_agent`        | `manager` 设置将用作管理器的自定义智能体。                                                                                               |
| **提示文件** _(可选)_     | `prompt_file`          | 团队使用的提示 JSON 文件路径。                                                                                                           |
| **规划** _(可选)_         | `planning`             | 为团队添加规划能力。激活后在每次团队迭代前，所有团队数据会发送到 AgentPlanner，规划任务并将此计划添加到每个任务描述中。                  |
| **规划 LLM** _(可选)_     | `planning_llm`         | 规划流程中 AgentPlanner 使用的语言模型。                                                                                                 |

<Tip>
  **团队最大 RPM**：`max_rpm`
  属性设置团队每分钟可执行的最大请求数以避免速率限制，如果设置会覆盖各个智能体的
  `max_rpm` 设置。
</Tip>

## 创建团队

在 CrewAI 中有两种创建团队的方式：使用 **YAML 配置（推荐）** 或 **直接在代码中定义**。

### YAML 配置（推荐）

使用 YAML 配置提供了更清洁、更易维护的团队定义方式，与 CrewAI 项目中定义智能体和任务的方式一致。

按照 [安装](/zh-Hans/installation) 部分创建 CrewAI 项目后，您可以在继承自 `CrewBase` 的类中定义团队，并使用装饰器定义智能体、任务和团队本身。

#### 使用装饰器的示例团队类

```python code
from crewai import Agent, Crew, Task, Process
from crewai.project import CrewBase, agent, task, crew, before_kickoff, after_kickoff
from crewai.agents.agent_builder.base_agent import BaseAgent
from typing import List

@CrewBase
class YourCrewName:
    """您的团队描述"""

    agents: List[BaseAgent]
    tasks: List[Task]

    # YAML 配置文件路径
    # 要查看在 YAML 中定义的示例智能体和任务，请查看以下内容：
    # - 任务：https://docs.crewai.com/concepts/tasks#yaml-configuration-recommended
    # - 智能体：https://docs.crewai.com/concepts/agents#yaml-configuration-recommended
    agents_config = 'config/agents.yaml'
    tasks_config = 'config/tasks.yaml'

    @before_kickoff
    def prepare_inputs(self, inputs):
        # 在团队开始前修改输入
        inputs['additional_data'] = "一些额外信息"
        return inputs

    @after_kickoff
    def process_output(self, output):
        # 在团队完成后修改输出
        output.raw += "\n在启动后处理。"
        return output

    @agent
    def agent_one(self) -> Agent:
        return Agent(
            config=self.agents_config['agent_one'], # type: ignore[index]
            verbose=True
        )

    @agent
    def agent_two(self) -> Agent:
        return Agent(
            config=self.agents_config['agent_two'], # type: ignore[index]
            verbose=True
        )

    @task
    def task_one(self) -> Task:
        return Task(
            config=self.tasks_config['task_one'] # type: ignore[index]
        )

    @task
    def task_two(self) -> Task:
        return Task(
            config=self.tasks_config['task_two'] # type: ignore[index]
        )

    @crew
    def crew(self) -> Crew:
        return Crew(
            agents=self.agents,  # 由 @agent 装饰器自动收集
            tasks=self.tasks,    # 由 @task 装饰器自动收集
            process=Process.sequential,
            verbose=True,
        )
```

如何运行上述代码：

```python code
YourCrewName().crew().kickoff(inputs={"any": "input here"})
```

<Note>任务将按定义的顺序执行。</Note>

`CrewBase` 类与这些装饰器一起自动收集智能体和任务，减少手动管理的需要。

#### `annotations.py` 中的装饰器概述

CrewAI 在 `annotations.py` 文件中提供了几个装饰器，用于标记团队类中的方法进行特殊处理：

- `@CrewBase`：将类标记为团队基类。
- `@agent`：表示返回 `Agent` 对象的方法。
- `@task`：表示返回 `Task` 对象的方法。
- `@crew`：表示返回 `Crew` 对象的方法。
- `@before_kickoff`：（可选）标记在团队开始前执行的方法。
- `@after_kickoff`：（可选）标记在团队完成后执行的方法。

这些装饰器帮助组织团队结构并自动收集智能体和任务，无需手动列出它们。

### 直接代码定义（替代方案）

或者，您可以直接在代码中定义团队，不使用 YAML 配置文件。

```python code
from crewai import Agent, Crew, Task, Process
from crewai_tools import YourCustomTool

class YourCrewName:
    def agent_one(self) -> Agent:
        return Agent(
            role="数据分析师",
            goal="分析市场数据趋势",
            backstory="拥有经济学背景的经验丰富的数据分析师",
            verbose=True,
            tools=[YourCustomTool()]
        )

    def agent_two(self) -> Agent:
        return Agent(
            role="市场研究员",
            goal="收集市场动态信息",
            backstory="具有敏锐细节观察力的勤奋研究员",
            verbose=True
        )

    def task_one(self) -> Task:
        return Task(
            description="收集最近的市场数据并识别趋势。",
            expected_output="总结市场关键趋势的报告。",
            agent=self.agent_one()
        )

    def task_two(self) -> Task:
        return Task(
            description="研究影响市场动态的因素。",
            expected_output="影响市场因素的分析。",
            agent=self.agent_two()
        )

    def crew(self) -> Crew:
        return Crew(
            agents=[self.agent_one(), self.agent_two()],
            tasks=[self.task_one(), self.task_two()],
            process=Process.sequential,
            verbose=True
        )
```

如何运行上述代码：

```python code
YourCrewName().crew().kickoff(inputs={})
```

在此示例中：

- 智能体和任务直接在类中定义，不使用装饰器。
- 我们手动创建和管理智能体和任务列表。
- 这种方法提供更多控制，但对大型项目可能不易维护。

## 团队输出

CrewAI 框架中团队的输出封装在 `CrewOutput` 类中。
此类提供了一种结构化的方式来访问团队执行结果，包括原始字符串、JSON 和 Pydantic 模型等各种格式。
`CrewOutput` 包括最终任务输出的结果、令牌使用情况和各个任务输出。

### 团队输出属性

| 属性          | 参数           | 类型                       | 描述                                                  |
| :------------ | :------------- | :------------------------- | :---------------------------------------------------- |
| **原始输出**  | `raw`          | `str`                      | 团队的原始输出。这是输出的默认格式。                  |
| **Pydantic**  | `pydantic`     | `Optional[BaseModel]`      | 表示团队结构化输出的 Pydantic 模型对象。              |
| **JSON 字典** | `json_dict`    | `Optional[Dict[str, Any]]` | 表示团队 JSON 输出的字典。                            |
| **任务输出**  | `tasks_output` | `List[TaskOutput]`         | `TaskOutput` 对象列表，每个代表团队中一个任务的输出。 |
| **令牌使用**  | `token_usage`  | `Dict[str, Any]`           | 令牌使用摘要，提供执行期间语言模型性能的见解。        |

### 团队输出方法和属性

| 方法/属性       | 描述                                                                     |
| :-------------- | :----------------------------------------------------------------------- |
| **json**        | 如果输出格式为 JSON，返回团队输出的 JSON 字符串表示。                    |
| **to_dict**     | 将 JSON 和 Pydantic 输出转换为字典。                                     |
| \***\*str\*\*** | 返回团队输出的字符串表示，优先顺序为 Pydantic、然后 JSON、然后原始输出。 |

### 访问团队输出

一旦团队执行完毕，可以通过 `Crew` 对象的 `output` 属性访问其输出。`CrewOutput` 类提供了与此输出交互和呈现的各种方式。

#### 示例

```python Code
# 示例团队执行
crew = Crew(
    agents=[research_agent, writer_agent],
    tasks=[research_task, write_article_task],
    verbose=True
)

crew_output = crew.kickoff()

# 访问团队输出
print(f"原始输出：{crew_output.raw}")
if crew_output.json_dict:
    print(f"JSON 输出：{json.dumps(crew_output.json_dict, indent=2)}")
if crew_output.pydantic:
    print(f"Pydantic 输出：{crew_output.pydantic}")
print(f"任务输出：{crew_output.tasks_output}")
print(f"令牌使用：{crew_output.token_usage}")
```

## 访问团队日志

您可以通过将 `output_log_file` 设置为 `True（布尔值）` 或 `file_name（字符串）` 来查看团队执行的实时日志。支持将事件记录为 `file_name.txt` 和 `file_name.json`。
如果为 `True（布尔值）`，将保存为 `logs.txt`。

如果 `output_log_file` 设置为 `False（布尔值）` 或 `None`，则不会生成日志。

```python Code
# 保存团队日志
crew = Crew(output_log_file = True)  # 日志将保存为 logs.txt
crew = Crew(output_log_file = file_name)  # 日志将保存为 file_name.txt
crew = Crew(output_log_file = file_name.txt)  # 日志将保存为 file_name.txt
crew = Crew(output_log_file = file_name.json)  # 日志将保存为 file_name.json
```

## 记忆利用

团队可以利用记忆（短期、长期和实体记忆）来增强其执行和随时间学习。此功能允许团队存储和回忆执行记忆，有助于决策和任务执行策略。

## 缓存利用

可以使用缓存来存储工具执行结果，通过减少重新执行相同任务的需要使流程更高效。

## 团队使用指标

团队执行后，您可以访问 `usage_metrics` 属性来查看团队执行的所有任务的语言模型（LLM）使用指标。这提供了对运营效率和改进领域的见解。

```python Code
# 访问团队的使用指标
crew = Crew(agents=[agent1, agent2], tasks=[task1, task2])
crew.kickoff()
print(crew.usage_metrics)
```

## 团队执行流程

- **顺序流程（Sequential Process）**：任务（Tasks）逐个执行，允许线性工作流。
- **分层流程（Hierarchical Process）**：管理器智能体（Manager Agent）协调团队，委派任务并在继续前验证结果。**注意**：此流程需要 `manager_llm` 或 `manager_agent`，对验证流程流程至关重要。

### 启动团队

一旦团队组建完成，使用 `kickoff()` 方法启动工作流程。这会根据定义的流程流开始执行过程。

```python Code
# 开始团队的任务执行
result = my_crew.kickoff()
print(result)
```

### 启动团队的不同方式

一旦团队组建完成，使用适当的启动方法启动工作流程。CrewAI 提供了几种方法以更好地控制启动过程：`kickoff()`、`kickoff_for_each()`、`kickoff_async()` 和 `kickoff_for_each_async()`。

- `kickoff()`：根据定义的流程流开始执行过程。
- `kickoff_for_each()`：为集合中的每个提供的输入事件或项目顺序执行任务。
- `kickoff_async()`：异步启动工作流程。
- `kickoff_for_each_async()`：为每个提供的输入事件或项目并发执行任务，利用异步处理。

```python Code
# 开始团队的任务执行
result = my_crew.kickoff()
print(result)

# 使用 kickoff_for_each 的示例
inputs_array = [{'topic': 'AI in healthcare'}, {'topic': 'AI in finance'}]
results = my_crew.kickoff_for_each(inputs=inputs_array)
for result in results:
    print(result)

# 使用 kickoff_async 的示例
inputs = {'topic': 'AI in healthcare'}
async_result = await my_crew.kickoff_async(inputs=inputs)
print(async_result)

# 使用 kickoff_for_each_async 的示例
inputs_array = [{'topic': 'AI in healthcare'}, {'topic': 'AI in finance'}]
async_results = await my_crew.kickoff_for_each_async(inputs=inputs_array)
for async_result in async_results:
    print(async_result)
```

这些方法在管理和执行团队内任务方面提供了灵活性，允许同步和异步工作流程以满足您的需求。

### 从特定任务重播

您现在可以使用我们的 CLI 命令 `replay` 从特定任务重播。

CrewAI 中的重播功能允许您使用命令行界面（CLI）从特定任务重播。通过运行命令 `crewai replay -t <task_id>`，您可以指定重播过程的 `task_id`。

启动现在会在本地保存最新启动返回的任务输出，以便您能够重播。

### 使用 CLI 从特定任务重播

要使用重播功能，请按照以下步骤：

1. 打开终端或命令提示符。
2. 导航到 CrewAI 项目所在的目录。
3. 运行以下命令：

要查看最新启动任务 ID，使用：

```shell
crewai log-tasks-outputs
```

然后，要从特定任务重播，使用：

```shell
crewai replay -t <task_id>
```

这些命令让您从最新启动任务重播，仍保持先前执行任务的上下文。
